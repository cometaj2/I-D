.\" Auto generated Nroff by NroffEdit on April 10, 2015
.pl 10.0i
.po 0
.ll 7.2i
.lt 7.2i
.nr LL 7.2i
.nr LT 7.2i
.ds LF Michaud
.ds RF FORMFEED[Page %]
.ds LH Internet-Draft
.ds RH March 17, 2017
.ds CH ALPS Bindings for HAL
.ds CF Expires September 18, 2017
.hy 0
.nh
.ad l
.in 0

.nf
.tl 'Network Working Group''J. Michaud'
.tl '\%Internet-Draft''March 17, 2017'
.tl 'Intended status: Informational'''
.tl 'Expires: September 18, 2017'''
.fi
.in 3


.ce 2
ALPS Bindings for HAL
\%draft-michaud-hal-alps-00

.ti 0
Abstract

This document defines ALPS bindings for the application/hal+json and application/hal+xml media-types.

.ti 0
Status of This Memo

This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.

Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.

Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."

.ti 0
Copyright Notice

Copyright (c) 2017 IETF Trust and the persons identified as the document authors.  All rights reserved.

This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents \%(http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.






.\" \# TD4  -- Set TOC depth by altering this value (TD5 = depth 5)
.\" \# TOC  -- Beginning of auto updated Table of Contents
.in 0
Table of Contents

.nf
   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  2
   2.  Requirements . . . . . . . . . . . . . . . . . . . . . . . . .  2
   3.  A Review of ALPS Principles  . . . . . . . . . . . . . . . . .  2
   4.  Servers and Clients  . . . . . . . . . . . . . . . . . . . . .  3
   5.  Advertising ALPS Profiles for HAL Representations  . . . . . .  3
     5.1.  HAL profile and type link relations  . . . . . . . . . . .  3
     5.2.  Link Header  . . . . . . . . . . . . . . . . . . . . . . .  4
     5.3.  Additional Considerations  . . . . . . . . . . . . . . . .  4
   6.  ALPS Bindings for HAL  . . . . . . . . . . . . . . . . . . . .  5
     6.1.  ALPS Descriptor Bindings . . . . . . . . . . . . . . . . .  5
       6.1.1.  id . . . . . . . . . . . . . . . . . . . . . . . . . .  6
       6.1.2.  name . . . . . . . . . . . . . . . . . . . . . . . . .  7
       6.1.3.  type . . . . . . . . . . . . . . . . . . . . . . . . .  8
         6.1.3.1. semantic  . . . . . . . . . . . . . . . . . . . . .  8
         6.1.3.2. safe, unsafe, or idempotent . . . . . . . . . . . . 10
       6.1.4.  rt . . . . . . . . . . . . . . . . . . . . . . . . . . 12
   7.  Recommendations  . . . . . . . . . . . . . . . . . . . . . . . 14
   8.  Security Considerations  . . . . . . . . . . . . . . . . . . . 14
   9.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 14
   10.  Normative References  . . . . . . . . . . . . . . . . . . . . 14
   11.  Informative References  . . . . . . . . . . . . . . . . . . . 14
   Appendix A.  Acknowledgements  . . . . . . . . . . . . . . . . . . 15
   Appendix B.  Frequently Asked Questions  . . . . . . . . . . . . . 15
   Author's Address . . . . . . . . . . . . . . . . . . . . . . . . . 15
.fi
.in 3

.\" \# ETC -- End of auto updated Table of Contents

.ti 0
1.  Introduction

.fi
In order to provide coherent use of Application Level Profile Semantics (ALPS) [I-D.draft-amundsen-richardson-foster-alps] in HAL documents [I-D.draft-kelly-json-hal] and [I-D.draft-michaud-xml-hal], ALPS bindings for the HAL media-types (application/hal+json and application/hal+xml) must be defined.

This specification establishes conventions required for consistent expression of Application Level Profile Semantics (ALPS) in HAL documents.

.ti 0
2.  Requirements

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC2119].

.ti 0
3.  A Review of ALPS Principles

The Application-Level Profile Semantics (ALPS) [I-D.draft-amundsen-richardson-foster-alps] specification is designed to describe the data elements and state transitions that make up a problem domain (e.g. micro-blogging, accounting, etc.). ALPS documents are designed to be useful to both client and server implementers and can be used at both run-time and design-time to handle the generation and interpretation of response representations. ALPS description documents are referred to as "profiles" or "profile documents".

Since the aim is to support a wide set of use cases (clients, servers, run-time, design-time, etc.), ALPS profiles do not describe the runtime behavior of any single system. Instead, ALPS profiles describe the problem domain boundaries (e.g. the possible data elements and possible state transitions). It is up to implementers to decide how they wish to use ALPS profiles in order to create an actual service instance or client application.

.ti 0
4.  Servers and Clients

For server implementers, ALPS profiles establish the list of possible identifiers for data values (givenName, familyName, etc.) and transitions (publish, createUser, etc). ALPS profiles also provide additional description information for state transitions including whether the transition is safe, idempotent or unsafe and, in some cases, whether there are any possible arguments that can be passed with each transition.

Client implementers can use the same ALPS document as a guide for what to expect from a service which advertises support for an ALPS profile. For example, if a service announces that it uses the ALPS profile for micro-blogging, then any client application that was built to support the micro-blogging profile SHOULD be able to recognize all the important data elements and state transitions emitted by that service.

.ti 0
5.  Advertising ALPS Profiles for HAL Representations

Servers returning HAL documents MUST only advertise the ALPS profiles they support using one of the following methods

.ti 0
5.1.  HAL profile and type link relations

HAL documents conforming to an ALPS profile SHOULD use the standard profile [RFC6906] and type [RFC6903] link relations HAL Link.

The profile link relation href SHOULD be set to the URL of the advertised ALPS profile.

The type link relation href SHOULD be set to the URL, with URL fragment referencing the descriptor.id of a semantic descriptor that exists in the referenced ALPS profile.

.nf
As application/hal+json:

{
  "_links": {
    "self": {
      "href": "/svc"
    },
    "profile": {
      "href": "http://example.org/profiles/accounting"
    },
    "type": {
      "href": "http://example.org/profiles/accounting#invoice"
    }
  }
}
.fi

.nf
As application/hal+xml:

<resource rel="self" href="/svc">
  <link rel="profile" href="http://example.org/profiles/accounting"/>
  <link rel="type" href="http://example.org/profiles/accounting"/>
</resource>
.fi

Precedence rules between Link Headers and HAL link relations SHOULD observer compliance per the ALPS specification Section 3.1. Linking to ALPS Documents [I-D.draft-amundsen-richardson-foster-alps].

.ti 0
5.2.  Link Header

Responses can include the Link header, in conformance with [RFC5988].

The profile and type link relations can also similarly be used.

Link: <http://example.org/profiles/accounting>;rel="profile", <http://example.org/profiles/accounting#invoice>;rel="type"

Precedence rules between Link Headers and HAL link relations SHOULD observer compliance per the ALPS specification Section 3.1. Linking to ALPS Documents [I-D.draft-amundsen-richardson-foster-alps].

.ti 0
5.3.  Additional Considerations

It is valid for a service to advertise support for more than one ALPS profile for the same response. For example, a single response from a server MAY include multiple HAL profile relations.

.nf
As application/hal+json:

{
  "_links": {
    "self": {
      "href": "/svc"
    },
    "profile": [{
      "href": "http://example.org/profiles/accounting"
    },
    {
      "href": "http://example.org/profiles/finance"
    }],
    "type": [{
      "href": "http://example.org/profiles/accounting#invoice"
    },
    {
      "href": "http://example.org/profiles/finance#billing"
    }]
  }
}
.fi

In the above case, the client application has been informed that the response MAY contain data elements and state transitions from both the accounting and finance ALPS profiles.

Clients accepting HAL documents, and understanding ALPS semantics, SHOULD look for the ALPS profile in each of the mentioned places (.e.g. Link Header, HAL Profile Relation), as appropriate to the response. If an ALPS profile reference appears in more than one location, all profiles SHOULD be considered valid.

Precedence rules between Link Headers and HAL link relations SHOULD observer compliance per the ALPS specification Section 3.1. Linking to ALPS Documents [I-D.draft-amundsen-richardson-foster-alps].

.ti 0
6.  ALPS Bindings for HAL

The following sections contain details and examples on how to bind ALPS to HAL.

.ti 0
6.1.  ALPS Descriptor Bindings

The following sections describe ALPS bindings for HAL, for the ALPS descriptor property.

.ti 0
6.1.1.  id

The descriptor.id, with a descriptor.type set to "semantic", SHOULD lead to the formation of a HAL document property with the same name as the descriptor.id.

Below are valid examples for both the application/hal+json and the application/hal+xml media-types:

.nf
<!-- ALPS document fragment -->
<descriptor id="section" type="semantic">
  <descriptor id="name" type="semantic" />
  <descriptor id="description" type="semantic" />
</descriptor>

As application/hal+json:

{
  "_links": {
    "self": {
      "href": "/svc"
    },
    "profile": [{
      "href": "http://example.org/profiles/hcli"
    }],
    "type": [{
      "href": "http://example.org/profiles/hcli#hcli-document"
    }]
  },
  "section": [
    {
      "name": "name",
      "description": "A simple formatter for JSON"
    },
    {
      "name": "synopsis",
      "description": "jsonf <command>"
    }
  ]
}

As application/hal+xml:

<resource self="/svc">
  <link rel="profile" href="http://example.org/profiles/hcli"/>
  <link rel="type" href="http://example.org/profiles/hcli#hcli-document"/>
  <section>
    <name>name</name>
    <description>A simple formatter for JSON</description>
  </section>
  <section>
    <name>synopsis</name>
    <description>jsonf &lt;command&gt;</description>
  </section>
</resource>
.fi

One notable and important exception exists when a semantic descriptor contains a non-semantic descriptor. This is covered in a later section covering non-semantic descriptor.type.

.ti 0
6.1.2.  name

The descriptor.name property SHOULD be used to help differentiate semantics when a condition would yield the required use of multiple identical descriptor.ids in an ALPS profile. Since having multiple identical descriptor.ids in an ALPS profile MUST NOT occur, the descriptor.id can remain unique within an ALPS profile and the descriptor.name MAY be used to otherwise lead to the formation of an identical key or link relation but with different application semantics.

The below example is simplistic but hints at how semantics could be differentiated when a need for identical keys is otherwise desirable.

.nf
<!-- ALPS document fragment -->
<descriptor id="media" type="semantic">
  <descriptor id="book-item" name="next" type="safe" />
  <descriptor id="movie-item" name="next" type="safe" />
</descriptor>

As application/hal+json:

{
  "_links": {
    "self": {
      "href": "/svc"
    },
    "profile": [{
      "href": "http://example.org/profiles/library"
    }],
    "type": [{
      "href": "http://example.org/profiles/library#media"
    }, 
    "next": [{
      "href": "/svc/book/2",
      "name": "book"
    },
    {
      "href": "/svc/movie/2",
      "name": "movie"
    }]
  }
}

As application/hal+xml:

<resource self="/svc">
  <link rel="profile" href="http://example.org/profiles/hcli"/>
  <link rel="type" href="http://example.org/profiles/hcli"/>
  <link rel="next" href="/svc/book/2" name="book"/>
  <link rel="next" href="/svc/movie/2" name="movie"/>
</resource>
.fi

.ti 0
6.1.3.  type

.ti 0
6.1.3.1. semantic

Coverage for the descriptor.type property with a value of "semantic" is covered under sections covering descriptor.id and descriptor.name.

However, an important and complex exception to the semantic descriptor.id case exists: when an ALPS profile semantic descriptor references a semantic descriptor that contains a non-semantic descriptor.

Such cases lead to the formation of linked resources, embedded resources, or both, in a HAL document. Determination of whether formation leads to the presence of a link, an embedded resource, or both, is left to service implementers.

If a service implementation SHOULD leads to the formation of a linked resource, the linked resource SHOULD contain a "profile" property referencing the URI of the ALPS profile, a "type" property referencing the URI of the ALPS profile, and fragment referencing the descriptor.id, or descriptor.name if appropriate, of the targeted semantic descriptor.

If a service implementation SHOULD leads to the formation of an embedded resource, the embedded resource SHOULD contain a "profile" link relation referencing the URI of the ALPS profile, a "type" link relation referencing the URI of the ALPS profile and fragment referencing the descriptor.id, or descriptor.name if appropriate, of the targeted semantic descriptor.

.nf
<!-- ALPS document fragments -->
<descriptor id="hcli-document" type="semantic">
  <descriptor href="#command">
</descriptor> 

<descriptor id="command" type="semantic">
  <descriptor id="item" type="safe">
    <doc>A link to an individual command summary.</doc>

    <descriptor id="next" type="unsafe">
      <doc>A link to select a command.</doc>
    </descriptor>
  </descriptor>
  <descriptor id="name" type="semantic" />
  <descriptor id="description" type="semantic" />
</descriptor> 

As application/hal+json:

{
  "_links": {
    "self": {
      "href": "/svc"
    },
    "profile": [{
      "href": "http://example.org/profiles/hcli"
    }],
    "type": [{
      "href": "http://example.org/profiles/hcli#hcli-document"
    },
    "item": {
      "href": "/svc/jsonf/def/go?command=jsonf",
      "profile": "http://example.org/profiles/hcli",
      "type" : "http://example.org/profiles/hcli#command"
    }
  },
  "_embedded" : {
    "item" : [{
      "_links" : {
        "self" : {
          "href" : "/svc/jsonf/def/go?command=jsonf"
        },
        "profile" : [{
          "href" : "http://example.org/profiles/hcli"
        }],
        "type" : [{
          "href" : "http://example.org/profiles/hcli#command"
        }],
        "next" : [{
          "href" : "/svc/jsonf?command=jsonf+go"
        }]
      },
      "description" : "Kicks off JSON formatting.",
      "name" : "go"
    }]
  }
}

As application/hal+xml:

<resource self="/svc">
  <link rel="profile" href="http://example.org/profiles/hcli"/>
  <link rel="type" href="http://example.org/profiles/hcli"/>
  <link rel="item"
        href="/svc/cli/jsonf/__cdef/go?command=jsonf"
        profile="http://example.org/profiles/hcli"
        type="http://example.org/profiles/hcli#command"/>
  <section>
    <name>name<name/>
    <description>A simple formatter for JSON</description>
  </section>
  <section>
    <name>synopsis<name/>
    <description>jsonf &lt;command&gt;</description>
  </section>
  <resource rel="item"
            href="/svc/cli/jsonf/__cdef/go?command=jsonf">
    <link rel="profile"
          href="http://example.org/profiles/hcli"/>
    <link rel="type"
          href="http://example.org/profiles/hcli#command"/>
    <link rel="next"
          href="/svc/jsonf?command=jsonf+go"/>
    <name>go</name>
    <description>Kicks off JSON formatting.</description>
  </resource>
</resource>
.fi 

.ti 0
6.1.3.2. safe, unsafe, or idempotent

If a non-semantic descriptor (e.g. "safe", "unsafe", or "idempotent") is otherwise not embedded in a referenced semantic descriptor, then it SHOULD yield the formation of a link or a templated link (a form). 

Notably, the profile and type properties on the link SHOULD be absent and the descriptor.id value SHOULD be used as the name of the value to fill in the URI template.

.ti 0
6.1.3.2.1.  Without a referenced semantic descriptor

If a non-semantic descriptor does not contain a semantic descriptor, then it SHOULD yield to the formation of a link.

.nf
<!-- ALPS document fragment -->
<descriptor id="media" type="semantic">
  <descriptor id="next" type="safe" />
</descriptor>

As application/hal+json:

{
  "_links": {
    "self": {
      "href": "/svc"
    },
    "profile": [{
      "href": "http://example.org/profiles/library"
    }],
    "type": [{
      "href": "http://example.org/profiles/library#media"
    }, 
    "next": [{
      "href": "/svc/book/2",
      "name": "book"
    },
    {
      "href": "/svc/movie/2",
      "name": "movie"
    }]
  }
}

As application/hal+xml:

<resource self="/svc">
  <link rel="profile" href="http://example.org/profiles/hcli"/>
  <link rel="type" href="http://example.org/profiles/hcli"/>
  <link rel="next" href="/svc/book/2" name="book"/>
  <link rel="next" href="/svc/movie/2" name="movie"/>
</resource>
.fi

.ti 0
6.1.3.2.2.  With a referenced semantic descriptor

If a non-semantic descriptor contains a semantic descriptor, then it SHOULD yield the formation of a templated link (a form).

.nf
<!-- ALPS document fragment -->
<descriptor id="search" type="semantic">
  <descriptor href="#collection" />
</descriptor>

<descriptor id="collection" type="safe">
  <doc format="text">A search form with one input.</doc>
  <descriptor id="id" type="semantic" />
</descriptor>

As application/hal+json:

{
  "_links": {
    "self": {
      "href": "/svc"
    },
    "profile": [{
      "href": "http://example.org/profiles/search"
    }],
    "type": [{
      "href": "http://example.org/profiles/search#search"
    },
    "collection": {
      "href": "/svc/search{?id}",
      "templated" : true
    }
  }
}

As application/hal+xml:

<resource self="/svc">
  <link rel="profile"
        href="http://example.org/profiles/hcli"/>
  <link rel="type"
        href="http://example.org/profiles/hcli"/>
  <link rel="collection"
        href="/svc/search{?rvalueId}"
        templated="true"/>
</resource>
.fi

.ti 0
6.1.4.  rt

The use of descriptor.rt on a semantic descriptor is undefined under this specification.

However, if descriptor.rt is used on a non-semantic descriptor, it SHOULD lead to the formation of a link referencing the specific semantic type referenced under descriptor.rt.

The return type of a non-semantic descriptor MUST NOT come in conflict with the implied return type of an embedded resource or link relation target described in this specification. The return type MAY however be used to make explicit the otherwise implied return type of an embedded resource or link relation target if the return type does not yield a conflict.

.nf
<!-- ALPS document fragment -->
<descriptor id="search" type="semantic">
  <descriptor href="#collection" />
  <descriptor href="#result" />
</descriptor>

<descriptor id="collection" type="safe" rt="#search">
  <doc format="text">A search form with one input.</doc>
  <descriptor id="id" type="semantic" />
</descriptor>

<descriptor id="result" type="semantic">
  <doc format="text">A returned search result.</doc>

  <descriptor id="item" type="safe" />
  <descriptor id="synopsis" type="semantic" />
  <descriptor id="ranking" type="semantic" />
</descriptor>

As application/hal+json:

{
  "_links": {
    "self": {
      "href": "/svc"
    },
    "profile": [{
      "href": "http://example.org/profiles/search"
    }],
    "type": [{
      "href": "http://example.org/profiles/search#search"
    },
    "collection": {
      "href": "/svc/search{?id}",
      "templated" : true,
      "profile": "http://example.org/profiles/search",
      "type" : "http://example.org/profiles/search#search"
    }
  }
}

As application/hal+xml:

<resource self="/svc">
  <link rel="profile"
        href="http://example.org/profiles/search"/>
  <link rel="type"
        href="http://example.org/profiles/search#search"/>
  <link rel="collection"
        href="/svc/search{?rvalueId}"
        templated="true",
        profile="http://example.org/profiles/search",
        type="http://example.org/profiles/search#search" />
</resource>
.fi

.ti 0
7.  Recommendations

TBD

.ti 0
8.  Security Considerations

TBD

.ti 0
9.  IANA Considerations

TBD

.ti 0
10.  Normative References

.in 14
.ti 3
[RFC6906]  Wilde, E., EMC Corporation, RFC 6906, March 2013

.ti 3
[RFC5988]  Nottingham, M., "Web Linking", RFC 5988, October 2010.

.ti 3
[RFC6903]  Snell, J., "Additional Link Relation Types", RFC 6903, March 2013

.ti 0
11.  Informative References
.fi

.in 14
.ti 3
[I-D.draft-amundsen-richardson-foster-alps]

Amundsen, M., CA Technologies, Inc., Richardson L., Foster, M., "Application-Level Profile Semantics (ALPS)", draft-amundsen-richardson-foster-alps-02 (work in
progress), August 2015.

.ti 3
[I-D.draft-kelly-json-hal]

Kelly, M., "JSON Hypertext Application Language", draft-kelly-json-hal-08 (work in progress), May 2016.

.ti 3
[I-D.draft-michaud-xml-hal]

Michaud, J., "XML Hypertext Application Language", draft-michaud-xml-hal-02 (work in progress), February 2017
.nf

.in 3
.ti 0
Appendix A.  Acknowledgements

.fi
TBD
.nf

.ti 0
Appendix B.  Frequently Asked Questions

TBD

.ti 0
Author's Address

.nf
Jeff Michaud

Email: cometaj2@comcast.net
Twitter: @cometaj2
